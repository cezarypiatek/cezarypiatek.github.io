<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Selenium on Cezary Piątek Blog</title>
    <link>https://cezarypiatek.github.io/tags/selenium/</link>
    <description>Recent content in Selenium on Cezary Piątek Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 Aug 2018 00:21:18 +0200</lastBuildDate>
    
	<atom:link href="https://cezarypiatek.github.io/tags/selenium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Feature Object Pattern</title>
      <link>https://cezarypiatek.github.io/post/feature-object-pattern/</link>
      <pubDate>Sun, 05 Aug 2018 00:21:18 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/feature-object-pattern/</guid>
      <description>When it comes to writing maintainable UI test there always appears the term of Page Object Pattern. For those who are not familiar with Page Object, it&amp;rsquo;s the approach to building UI test that focuses on creating high-level abstraction over low-level details related to interaction with a tested application. This testing interface encapsulates all the noise related to technology and allows to clearly express intention of test cases. This concept is very well described by Martin Fowler here.</description>
    </item>
    
    <item>
      <title>Reactive testing</title>
      <link>https://cezarypiatek.github.io/post/reactive-testing/</link>
      <pubDate>Sat, 21 Jul 2018 00:21:18 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/reactive-testing/</guid>
      <description>public class UserListPage() { private readonly WebDriver driver; private readonly Lazy&amp;lt;Form&amp;gt; filterForm; private readonly Lazy&amp;lt;List&amp;gt; userList; private readonly new Lazy&amp;lt;List&amp;gt; listPagination; public UserListPage(WebDriver driver){ this.driver = driver; this.filterForm = new Lazy&amp;lt;Form&amp;gt;(x=&amp;gt; driver.FindFormWithId(&amp;quot;UserFilterForm&amp;quot;)); this.userList = new Lazy&amp;lt;List&amp;gt;(x=&amp;gt; driver.FindListWithId(&amp;quot;UserList&amp;quot;)); this.listPagination = new Lazy&amp;lt;List&amp;gt;(x=&amp;gt; driver.FindListWithId(&amp;quot;UserListPagination&amp;quot;)); } public void FilterWith(Action&amp;lt;Form&amp;gt; fillFilterFormAction) { fillFilterFormAction(this.filterForm); this.userList.Value.AffectWith(()=&amp;gt; this.filterForm.Value.ClickOnElementWithText(&amp;quot;Filter&amp;quot;)); } public void LoadPage(int pageNo){ this.userList.Value.AffectWith(()=&amp;gt; this.listPagination.Value.ClickOnElementWithText($&amp;quot;{pageNo}&amp;quot;)); } public int GetNumberOfUsers(){ return this.userList.Value.Count; } public void OpenUserDetails(string userName) { var listItem = this.</description>
    </item>
    
    <item>
      <title>Why clicking with Selenium is so hard.</title>
      <link>https://cezarypiatek.github.io/post/why-click-with-selenium-so-hard/</link>
      <pubDate>Thu, 05 Oct 2017 17:38:18 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/why-click-with-selenium-so-hard/</guid>
      <description>When I browse StackOverflow questions tagged with selenium label, a lot of them are related to the problem of clicking on page elements. It seems to be one of the most trivial tasks, but can cause a lot of problems. Very often invoking Click() action on webelement ends with exceptions (there is a wide range of them). The main reason is that element on which we try to click is not in &amp;ldquo;Interactable&amp;rdquo; state.</description>
    </item>
    
  </channel>
</rss>