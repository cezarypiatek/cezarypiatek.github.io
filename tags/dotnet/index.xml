<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dotnet on Cezary Piątek Blog</title>
    <link>https://cezarypiatek.github.io/tags/dotnet/</link>
    <description>Recent content in dotnet on Cezary Piątek Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Mar 2021 00:08:00 +0200</lastBuildDate>
    
	<atom:link href="https://cezarypiatek.github.io/tags/dotnet/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Testing WebAPI with ApprovalTests.NET</title>
      <link>https://cezarypiatek.github.io/post/testing-web-api-with-approval-tests/</link>
      <pubDate>Tue, 16 Mar 2021 00:08:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/testing-web-api-with-approval-tests/</guid>
      <description>&lt;p&gt;In this blog post, I&amp;rsquo;m going to share my experience on testing &lt;code&gt;ASP.NET Core&lt;/code&gt; applications by applying an unconventional method called &lt;code&gt;snapshot assertions&lt;/code&gt;. In comparison to the classical approach, this method should save you a lot of time and improve assertions maintainability.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pure functions and unused return values</title>
      <link>https://cezarypiatek.github.io/post/pure-functions-and-unused-return-value/</link>
      <pubDate>Tue, 16 Feb 2021 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/pure-functions-and-unused-return-value/</guid>
      <description>A while ago I came across &amp;ldquo;Quick notes on a rant&amp;rdquo; authored by Don Syme. This rant criticizes the C# language for the lack of a few important features. The first point is &amp;quot;Implicitly discarding information is so 20th Century&amp;quot; which brings our attention to one of the sources of bugs in C# programs. Lucky me, I got the pleasure to make this kind of bug and find it later in production code, so this blog post is to save you the trouble.</description>
    </item>
    
    <item>
      <title>Github Actions for Visual Studio Extension developers</title>
      <link>https://cezarypiatek.github.io/post/develop-vsextension-with-github-actions/</link>
      <pubDate>Sun, 24 Jan 2021 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/develop-vsextension-with-github-actions/</guid>
      <description>I discovered the power of Roslyn over three years ago and since then I&amp;rsquo;ve developed three Visual Studio extensions and a couple of code analyzers. Because I work on those tools only in my free time, the word &amp;ldquo;time&amp;rdquo; is a key here, so automation really matters. So far I&amp;rsquo;ve been using AppVeyor for building and testing my extensions. However, I&amp;rsquo;m a huge fan of integrated solutions because they require much less work for setup, and since GithubActions became generally available I wanted to give it a try.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Summary</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-summary/</link>
      <pubDate>Tue, 03 Nov 2020 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-summary/</guid>
      <description>In the last two posts, I&amp;rsquo;ve described 14 different code smells related to the async/await keywords. Beside the problem description, I&amp;rsquo;ve also provided info about code analyzers that can detect and report given issue. Those analyzers come from a few different packages that are not strictly devoted to the asynchronous programming area. They also contain rules from other fields with predefined severity, which might not be appropriate to your needs, or you might not be interested in enforcing them at all.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Part II</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-p2/</link>
      <pubDate>Sun, 18 Oct 2020 16:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-p2/</guid>
      <description>This blog post continues the series which is a guide through the code analyzers available on the market and their possibilities. I&amp;rsquo;m trying to help you answer the question: &amp;ldquo;Which analyzer package should I use and how to configure it to avoid problems related to async/await?&amp;rdquo;. In the previous episode, I presented the first seven most common code smells related to asynchronous programming. Today, I present the next seven traps from this area.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Part I</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-p1/</link>
      <pubDate>Sun, 11 Oct 2020 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-p1/</guid>
      <description>Roslyn analyzers are great. Not only do they detect different issues in our code, but they are also able to propose solutions, thanks to accompanying code fixes. There&amp;rsquo;s one more, less-advertised aspect of analyzers: besides improving the quality of our codebase, they also improve the state of language knowledge in our teams. This is a real time-saver during the code review because the technical, language-related remarks are reported automatically in design/build time.</description>
    </item>
    
    <item>
      <title>Working efficiently with legacy database using Dapper</title>
      <link>https://cezarypiatek.github.io/post/dapper-tips-and-tricks/</link>
      <pubDate>Sun, 02 Aug 2020 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/dapper-tips-and-tricks/</guid>
      <description>A year ago I started working on a set of projects that requires accessing data from a huge legacy database. There was a decision to use Dapper to facilitate database access code. For those of you who are not familiar with Dapper, it&amp;rsquo;s a set of extension methods to IDbConnection, which allows to easily map C# object to SQL query parameters, as well as SQL query result to C# objects.</description>
    </item>
    
    <item>
      <title>The Magical Methods in C#</title>
      <link>https://cezarypiatek.github.io/post/methods-with-special-signature/</link>
      <pubDate>Tue, 30 Jun 2020 00:08:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/methods-with-special-signature/</guid>
      <description>There&amp;rsquo;s a certain set of special method signatures in C# which have particular support on the language level. Methods with those signatures allow for using a special syntax which has several benefits. For example, we can use them to simplify our code or create DSL to express a solution to our domain-specific problem in a much cleaner way. I came across those methods in different places, so I decided to create a blog post to summarize all my discoveries on this subject.</description>
    </item>
    
    <item>
      <title>Twin types - properties synchronization without inheritance</title>
      <link>https://cezarypiatek.github.io/post/csharp-twin-types/</link>
      <pubDate>Sun, 14 Jun 2020 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/csharp-twin-types/</guid>
      <description>A couple of months ago I&amp;rsquo;ve started working on a simple CRUD service. A mix of ASP Core for REST API with Dapper for Database access - probably one of the most popular stacks for this kind of application. Very quickly it turned out that it&amp;rsquo;s more complex than I expected and this &amp;ldquo;simple-boring&amp;rdquo; CRUD became more interesting and challenging.
The Problem One of the first problems that I came across was that I had a lot of types that looked very similar but had some differences and served different purposes, like:</description>
    </item>
    
    <item>
      <title>Improving non-nullable reference types handling</title>
      <link>https://cezarypiatek.github.io/post/better-non-nullable-handling/</link>
      <pubDate>Tue, 24 Mar 2020 20:00:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/better-non-nullable-handling/</guid>
      <description>A few weeks ago I started using non-nullable reference types - a new C# language feature which was shipped with version 8.0. It wasn&amp;rsquo;t a completely new experience for me, because I was working before on projects that were heavily utilizing [NotNull] and [CanBeNull] Resharper annotations. The way how non-nullable types are handled by Roslyn seems to be a little more complex in comparison to Resharper - there are around 40 different diagnostics related to this area.</description>
    </item>
    
    <item>
      <title>How to simulate AutoMapper that works during the build time</title>
      <link>https://cezarypiatek.github.io/post/generate-mappings-on-build/</link>
      <pubDate>Sun, 01 Dec 2019 00:09:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/generate-mappings-on-build/</guid>
      <description>Almost two years ago I created the very first version of MappingGenerator. Since then, I&amp;rsquo;ve put a lot of work in this project, adding new functions and improving the mapping generation algorithm with 14 releases (43 issues/feature requests closed) in the meantime. With over 5.5k downloads from the marketplace and 380 stars on Github, it looks like there is quite a market demand for this kind of tool (even though my coffee button statistics indicate something different).</description>
    </item>
    
    <item>
      <title>Exception usage analyzer</title>
      <link>https://cezarypiatek.github.io/post/exceptions-usages-analyzer/</link>
      <pubDate>Sat, 29 Jun 2019 00:09:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/exceptions-usages-analyzer/</guid>
      <description>Over a year ago I wrote a blog post about designing exceptions. I found this article very useful by myself and I used it as a reference a few times during code review. However, it&amp;rsquo;s almost impossible to expect that, after reading the recommended resource, anybody would start to apply described rules immediately and remember about them all the time. It&amp;rsquo;s a learning process and it takes some time. A while ago I got interested with Roslyn (I even delivered a public presentation about it - polish recording available here) and there is a really cool thing about Roslyn analyzers that can solve this problem - they help to actively introduce best practices into your codebase.</description>
    </item>
    
    <item>
      <title>Renovate your .NET solution</title>
      <link>https://cezarypiatek.github.io/post/renovate-your-dot-net-solution/</link>
      <pubDate>Mon, 11 Feb 2019 00:20:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/renovate-your-dot-net-solution/</guid>
      <description>In the early days of dotnet core, there was an attempt of changing the C# project file format. The old &amp;ldquo;csproj&amp;rdquo; based on XML format was replaced with .xproj/project.json. However, after releasing dotnet core 1.0 the authors decided to get back to XML file. The format stayed the same but the specification went through a major change. With the new schema, a lot of improvements come into .net development and they are not restricted only to dotnet core projects.</description>
    </item>
    
    <item>
      <title>The art of designing exceptions</title>
      <link>https://cezarypiatek.github.io/post/the-art-of-designing-exceptions/</link>
      <pubDate>Fri, 19 Oct 2018 00:09:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/the-art-of-designing-exceptions/</guid>
      <description>Have you ever been in a situation when you discovered an exception in the logs that forced you to spend the next couple of minutes - or even hours - figuring out what exactly went wrong? The message was very cryptic and the only useful information that guided you to the crime scene was a stack trace. And after arriving there, you still had no idea what had really happened and what was the culprit.</description>
    </item>
    
    <item>
      <title>Generate mapping code with Roslyn code fix provider.</title>
      <link>https://cezarypiatek.github.io/post/generate-mapping-code-with-roslyn/</link>
      <pubDate>Tue, 27 Feb 2018 00:23:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/generate-mapping-code-with-roslyn/</guid>
      <description>A few weeks ago I posted about negative aspects of applying AutoMapper. As an alternative I suggested typing all mapping code by hand or utilize some kind of generator like T4Scaffoling or something Roslyn based. In the past I experimented with T4Scaffoling but it was quite tedious. It requires preparation of templates in T4 syntax, referencing it to the project and writing some PowerShell code to provide data for templates. There also was an issue with assembly locking.</description>
    </item>
    
    <item>
      <title>The reasons behind why I don&#39;t use AutoMapper.</title>
      <link>https://cezarypiatek.github.io/post/why-i-dont-use-automapper/</link>
      <pubDate>Mon, 05 Feb 2018 00:22:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/why-i-dont-use-automapper/</guid>
      <description>The idea behind this blog post is pretty old but I haven&amp;rsquo;t had enough motivation to write this down till now. Recently, I&amp;rsquo;ve came across a couple of new articles about AutoMapper and I&amp;rsquo;ve been struck when I saw how people utilize AutoMapper in their projects. I&amp;rsquo;ve encountered cases when AutoMapper transforms simple thing like mapping values from object to other into a really complex problem, which results with highly complicated code only for the price of not writing mappings explicitly.</description>
    </item>
    
  </channel>
</rss>