<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dotnetcore on Cezary Piątek Blog</title>
    <link>https://cezarypiatek.github.io/tags/dotnetcore/</link>
    <description>Recent content in dotnetcore on Cezary Piątek Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Aug 2021 00:21:45 +0200</lastBuildDate><atom:link href="https://cezarypiatek.github.io/tags/dotnetcore/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Readable and clear tests for ASP.NET Core services</title>
      <link>https://cezarypiatek.github.io/post/component-tests-scenarios/</link>
      <pubDate>Mon, 09 Aug 2021 00:21:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/component-tests-scenarios/</guid>
      <description>For the last year, I&amp;rsquo;ve had an opportunity to work quite a lot with Component Tests for microservices built with ASP.NET Core. The vocabulary related to testing is very vague and terms like Unit, Component, and Integration tests can be interpreted differently based on the context, so let me explain first what I mean by Component Tests. It&amp;rsquo;s a kind of test that treats your whole service as a black box.</description>
    </item>
    
    <item>
      <title>Github Actions for Visual Studio Extension developers</title>
      <link>https://cezarypiatek.github.io/post/develop-vsextension-with-github-actions/</link>
      <pubDate>Sun, 24 Jan 2021 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/develop-vsextension-with-github-actions/</guid>
      <description>I discovered the power of Roslyn over three years ago and since then I&amp;rsquo;ve developed three Visual Studio extensions and a couple of code analyzers. Because I work on those tools only in my free time, the word &amp;ldquo;time&amp;rdquo; is a key here, so automation really matters. So far I&amp;rsquo;ve been using AppVeyor for building and testing my extensions. However, I&amp;rsquo;m a huge fan of integrated solutions because they require much less work for setup, and since GithubActions became generally available I wanted to give it a try.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Summary</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-summary/</link>
      <pubDate>Tue, 03 Nov 2020 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-summary/</guid>
      <description>In the last two posts, I&amp;rsquo;ve described 14 different code smells related to the async/await keywords. Beside the problem description, I&amp;rsquo;ve also provided info about code analyzers that can detect and report given issue. Those analyzers come from a few different packages that are not strictly devoted to the asynchronous programming area. They also contain rules from other fields with predefined severity, which might not be appropriate to your needs, or you might not be interested in enforcing them at all.</description>
    </item>
    
    <item>
      <title>Setting assembly and nuget package metadata in .NET Core</title>
      <link>https://cezarypiatek.github.io/post/setting-assembly-and-package-metadata/</link>
      <pubDate>Mon, 09 Dec 2019 00:09:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/setting-assembly-and-package-metadata/</guid>
      <description>The new csproj format introduces two major changes that are important from the artifact metadata management perspective. First of all, a NuGet package definition was moved into the project file which allows sharing common attributes between NuGet package manifest and assembly info. Secondly, a new mechanism for generating source code of assembly metadata attributes was added, which shares some benefits from the first feature as well as simplify how these values can be overridden during the build process.</description>
    </item>
    
    <item>
      <title>Managing output in the .NET SDK projects</title>
      <link>https://cezarypiatek.github.io/post/managing-output-in-sdk-projects/</link>
      <pubDate>Sun, 03 Nov 2019 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/managing-output-in-sdk-projects/</guid>
      <description>With the new SDK format for .NET projects, it&amp;rsquo;s much easier to manage with the project&amp;rsquo;s dependencies. In most scenarios references added with standard mechanism (Visual Studio or dotnet cli) result in sufficient content in the output directory. However, sometimes we want to do something non-standard that requires a slightly different set of components in the output dir - simply speaking we expect to see there either more or fewer files.</description>
    </item>
    
    <item>
      <title>Non-nullable references with C# 8 and .NET Core 3.0</title>
      <link>https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/</link>
      <pubDate>Sun, 06 Oct 2019 00:16:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/</guid>
      <description>Two weeks ago .NET Core 3.0 was officially published. Together with the new framework version, Visual Studio 2019 got support for a long-awaited C# 8.0. The complete list of the new language features is available here on the MSDN, but the one that deserves special attention is Nullable reference types. This is a very important change in the language semantic, because from now we will be able to eliminate certain class of errors related to reference nullability on the compilation stage.</description>
    </item>
    
  </channel>
</rss>
