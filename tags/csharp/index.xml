<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>csharp on Cezary Piątek Blog</title>
    <link>https://cezarypiatek.github.io/tags/csharp/</link>
    <description>Recent content in csharp on Cezary Piątek Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Mar 2021 00:08:00 +0200</lastBuildDate>
    
	<atom:link href="https://cezarypiatek.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Testing WebAPI with ApprovalTests.NET</title>
      <link>https://cezarypiatek.github.io/post/testing-web-api-with-approval-tests/</link>
      <pubDate>Tue, 16 Mar 2021 00:08:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/testing-web-api-with-approval-tests/</guid>
      <description>&lt;p&gt;In this blog post, I&amp;rsquo;m going to share my experience on testing &lt;code&gt;ASP.NET Core&lt;/code&gt; applications by applying an unconventional method called &lt;code&gt;snapshot assertions&lt;/code&gt;. In comparison to the classical approach, this method should save you a lot of time and improve assertions maintainability.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pure functions and unused return values</title>
      <link>https://cezarypiatek.github.io/post/pure-functions-and-unused-return-value/</link>
      <pubDate>Tue, 16 Feb 2021 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/pure-functions-and-unused-return-value/</guid>
      <description>A while ago I came across &amp;ldquo;Quick notes on a rant&amp;rdquo; authored by Don Syme. This rant criticizes the C# language for the lack of a few important features. The first point is &amp;quot;Implicitly discarding information is so 20th Century&amp;quot; which brings our attention to one of the sources of bugs in C# programs. Lucky me, I got the pleasure to make this kind of bug and find it later in production code, so this blog post is to save you the trouble.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Summary</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-summary/</link>
      <pubDate>Tue, 03 Nov 2020 10:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-summary/</guid>
      <description>In the last two posts, I&amp;rsquo;ve described 14 different code smells related to the async/await keywords. Beside the problem description, I&amp;rsquo;ve also provided info about code analyzers that can detect and report given issue. Those analyzers come from a few different packages that are not strictly devoted to the asynchronous programming area. They also contain rules from other fields with predefined severity, which might not be appropriate to your needs, or you might not be interested in enforcing them at all.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Part II</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-p2/</link>
      <pubDate>Sun, 18 Oct 2020 16:00:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-p2/</guid>
      <description>This blog post continues the series which is a guide through the code analyzers available on the market and their possibilities. I&amp;rsquo;m trying to help you answer the question: &amp;ldquo;Which analyzer package should I use and how to configure it to avoid problems related to async/await?&amp;rdquo;. In the previous episode, I presented the first seven most common code smells related to asynchronous programming. Today, I present the next seven traps from this area.</description>
    </item>
    
    <item>
      <title>Async code smells and how to track them down with analyzers - Part I</title>
      <link>https://cezarypiatek.github.io/post/async-analyzers-p1/</link>
      <pubDate>Sun, 11 Oct 2020 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/async-analyzers-p1/</guid>
      <description>Roslyn analyzers are great. Not only do they detect different issues in our code, but they are also able to propose solutions, thanks to accompanying code fixes. There&amp;rsquo;s one more, less-advertised aspect of analyzers: besides improving the quality of our codebase, they also improve the state of language knowledge in our teams. This is a real time-saver during the code review because the technical, language-related remarks are reported automatically in design/build time.</description>
    </item>
    
    <item>
      <title>The Magical Methods in C#</title>
      <link>https://cezarypiatek.github.io/post/methods-with-special-signature/</link>
      <pubDate>Tue, 30 Jun 2020 00:08:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/methods-with-special-signature/</guid>
      <description>There&amp;rsquo;s a certain set of special method signatures in C# which have particular support on the language level. Methods with those signatures allow for using a special syntax which has several benefits. For example, we can use them to simplify our code or create DSL to express a solution to our domain-specific problem in a much cleaner way. I came across those methods in different places, so I decided to create a blog post to summarize all my discoveries on this subject.</description>
    </item>
    
    <item>
      <title>Twin types - properties synchronization without inheritance</title>
      <link>https://cezarypiatek.github.io/post/csharp-twin-types/</link>
      <pubDate>Sun, 14 Jun 2020 00:11:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/csharp-twin-types/</guid>
      <description>A couple of months ago I&amp;rsquo;ve started working on a simple CRUD service. A mix of ASP Core for REST API with Dapper for Database access - probably one of the most popular stacks for this kind of application. Very quickly it turned out that it&amp;rsquo;s more complex than I expected and this &amp;ldquo;simple-boring&amp;rdquo; CRUD became more interesting and challenging.
The Problem One of the first problems that I came across was that I had a lot of types that looked very similar but had some differences and served different purposes, like:</description>
    </item>
    
    <item>
      <title>Improving non-nullable reference types handling</title>
      <link>https://cezarypiatek.github.io/post/better-non-nullable-handling/</link>
      <pubDate>Tue, 24 Mar 2020 20:00:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/better-non-nullable-handling/</guid>
      <description>A few weeks ago I started using non-nullable reference types - a new C# language feature which was shipped with version 8.0. It wasn&amp;rsquo;t a completely new experience for me, because I was working before on projects that were heavily utilizing [NotNull] and [CanBeNull] Resharper annotations. The way how non-nullable types are handled by Roslyn seems to be a little more complex in comparison to Resharper - there are around 40 different diagnostics related to this area.</description>
    </item>
    
    <item>
      <title>How to simulate AutoMapper that works during the build time</title>
      <link>https://cezarypiatek.github.io/post/generate-mappings-on-build/</link>
      <pubDate>Sun, 01 Dec 2019 00:09:00 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/generate-mappings-on-build/</guid>
      <description>Almost two years ago I created the very first version of MappingGenerator. Since then, I&amp;rsquo;ve put a lot of work in this project, adding new functions and improving the mapping generation algorithm with 14 releases (43 issues/feature requests closed) in the meantime. With over 5.5k downloads from the marketplace and 380 stars on Github, it looks like there is quite a market demand for this kind of tool (even though my coffee button statistics indicate something different).</description>
    </item>
    
    <item>
      <title>Non-nullable references with C# 8 and .NET Core 3.0</title>
      <link>https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/</link>
      <pubDate>Sun, 06 Oct 2019 00:16:45 +0200</pubDate>
      
      <guid>https://cezarypiatek.github.io/post/non-nullable-references-in-dotnet-core/</guid>
      <description>Two weeks ago .NET Core 3.0 was officially published. Together with the new framework version, Visual Studio 2019 got support for a long-awaited C# 8.0. The complete list of the new language features is available here on the MSDN, but the one that deserves special attention is Nullable reference types. This is a very important change in the language semantic, because from now we will be able to eliminate certain class of errors related to reference nullability on the compilation stage.</description>
    </item>
    
  </channel>
</rss>